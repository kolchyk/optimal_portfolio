Проблема, которую вы описываете (стратегия отстает от простого удержания S&P 500 и находится ниже кривой эффективного фронта Марковица), является классическим симптомом трендовых кросс-активных стратегий с избыточно жесткими правилами снижения риска.

Ваша стратегия отлично режет просадки, но **математически лишена механизмов максимизации прибыли**. Детальный анализ вашего кода выявил **5 критических архитектурных и логических ошибок**.

Ниже разобран каждый баг и приведен код для его устранения.

---

### 1. Ловушка Risk Parity (Кэш-эквиваленты съедают капитал)

**Где:** `engine.py` и `strategy_v2/engine.py` (функция `_compute_inverse_vol_weights_fast`)
**Почему это убивает Шарп:** Вы считаете веса как `1.0 / vol`. В вашем `ETF_UNIVERSE` есть фонды ультракоротких облигаций (`SGOV`, `SHV`), волатильность которых стремится к нулю. Если `SGOV` пройдет фильтры, его расчетный вес из-за околонулевой волатильности будет в десятки раз больше, чем у акций. Алгоритм может вложить 80-90% капитала в фонд с доходностью 5% годовых, оставляя копейки на растущие акции.
**Как исправить:** Установите минимальный «пол» (floor) волатильности, чтобы ограничить аллокацию в сверхспокойные активы.

```python
def _compute_inverse_vol_weights_fast(tickers_to_buy: list[str], vol_row: pd.Series) -> dict[str, float]:
    if not tickers_to_buy: return {}
    inv_vols: dict[str, float] = {}
    
    # Пол дневной волатильности (эквивалент ~5-7% годовых)
    min_vol = 0.06 / (252 ** 0.5)

    for t in tickers_to_buy:
        vol = vol_row.get(t, np.nan)
        if np.isnan(vol): continue
        
        # Защита от околонулевой волатильности
        vol = max(vol, min_vol)
        
        if vol > 1e-8:
            inv_vols[t] = 1.0 / vol
        else:
            inv_vols[t] = 1.0

    return _inv_vols_to_weights(inv_vols, tickers_to_buy)

```

### 2. Синдром «Зомби-активов» (Lazy Hold)

**Где:** `engine.py` (правила продажи)
**Почему это убивает доходность:** В комментариях у вас написано: *"positions are sold ONLY when their own KAMA stop-loss triggers"*. Если актив вырос на 30%, а затем ушел в боковик на год, его цена останется выше медленной KAMA. Алгоритм его не продаст. Он будет занимать ценный слот (`top_n`), давая нулевую доходность, в то время как новые лидеры (например, AI-сектор) игнорируются, так как нет свободных слотов. Это создает колоссальные альтернативные издержки (Opportunity Cost).
**Как исправить:** Внедрите **Relative Momentum Stop**. Если актив стагнирует и выпадает из топа лидеров, продавайте его.

```python
        # Генерируем расширенный список кандидатов (Топ-N * 3) для создания буфера удержания
        extended_candidates = get_buy_candidates(
            prices_row, tickers, kama_current,
            kama_buffer=p.kama_buffer, top_n=p.top_n * 3,
            use_risk_adjusted=p.use_risk_adjusted,
            precomputed_momentum=momentum_df.loc[date],
            precomputed_er=er_df.loc[date],
        )
        
        # В покупки идут только самые лучшие
        candidates = extended_candidates[:p.top_n]

        for t in list(shares.keys()):
            t_kama = kama_row.get(t, np.nan)
            if not np.isnan(t_kama):
                # 1. Трендовый стоп (как у вас)
                if daily_close.get(t, 0.0) < t_kama * (1 - p.kama_buffer):
                    sells[t] = 0.0
                # 2. НОВОЕ: Ротационный стоп (актив остыл и вылетел из расширенного топа)
                elif t not in extended_candidates:
                    sells[t] = 0.0

```

### 3. Критический баг недоинвестированности в V2

**Где:** `strategy_v2/engine.py` (строка ~348) и параметры `strategy_v2/config.py`
**Почему вы отстаете от SP500:** Вы ввели параметры `target_vol = 0.10` и `max_leverage = 1.5`, чтобы брать плечо на спокойных рынках. Но в коде стоит жесткий лимит:
`target_invested = equity_at_open * min(scale, 1.0) # cap at 100%`
Из-за `min(scale, 1.0)` алгоритм **никогда не увеличивает** позицию выше 100%. Он только *срезает* капитал в кризис. Поскольку волатильность SP500 равна ~16-18%, а ваш таргет всего 10%, ваш портфель постоянно находится в кэше на 30-40%. Без использования заложенного левериджа стратегия математически обречена проигрывать индексу.
**Как исправить:**
Если маржа доступна, разрешите `min(scale, p.max_leverage)`.
Если вы торгуете без маржи, поднимите диапазоны таргета волатильности в `V2_SEARCH_SPACE` до уровня рынка:

```python
"target_vol": {"type": "float", "low": 0.14, "high": 0.20, "step": 0.02},
# Удалите min(scale, 1.0) если хотите использовать плечо:
# target_invested = equity_at_open * min(scale, p.max_leverage)

```

### 4. Тотальный Risk-Off уничтожает "Crisis Alpha"

**Где:** `engine.py` (строки ~138)
**Почему это снижает Шарп:** Когда S&P 500 падает (`risk_off = True`), вы продаете абсолютно всё. Но в вашем портфеле есть Гособлигации (`TLT`, `IEF`) и Золото (`GLD`). Их фундаментальная задача — **расти** во время обвала акций ("Flight to safety"). Распродавая их в кэш (под безрисковую ставку), вы лишаете портфель способности зарабатывать в кризис.
**Как исправить:** В режиме Risk-Off продавайте только акции/крипту и активно скупайте защитные активы.

```python
from src.portfolio_sim.config import ASSET_CLASS_MAP

        safe_haven_classes = ["Long Bonds", "Mid Bonds", "Short Bonds", "Corporate Bonds", "Metals"]

        if risk_off:
            # 1. Сбрасываем только рисковые активы
            for t in list(shares.keys()):
                if ASSET_CLASS_MAP.get(t, "US Equity") not in safe_haven_classes:
                    sells[t] = 0.0
            
            # 2. Ищем кандидатов на покупку ТОЛЬКО среди защитных гаваней
            safe_tickers = [t for t in tickers if ASSET_CLASS_MAP.get(t, "") in safe_haven_classes]
            candidates = get_buy_candidates(
                prices_row, safe_tickers, kama_current,
                kama_buffer=p.kama_buffer, top_n=p.top_n,
                use_risk_adjusted=p.use_risk_adjusted,
                precomputed_momentum=momentum_df.loc[date],
                precomputed_er=er_df.loc[date],
            )

```

### 5. Токсичный фильтр корреляции на бычьем рынке

**Где:** `engine.py` (фильтр `corr_threshold`)
**Почему это вредит:** На мощных бычьих рынках (как 2020, 2023, 2024) все топовые акции растут синхронно с высокой корреляцией. Если алгоритм купит лидера `NVDA`, жесткий порог (например, 0.7) заставит его отбросить `MSFT`, `AAPL` и `AMD`. Алгоритму придется забивать оставшиеся слоты стагнирующими отстающими секторами (вроде Consumer Staples) "ради диверсификации".
**Как исправить:** У вас уже включен `weighting_mode = "risk_parity"`, который отлично балансирует риски естественным путем.
Расширьте в `config.py` пространство поиска: `"corr_threshold": {"type": "float", "low": 0.85, "high": 1.0, "step": 0.05}` (разрешите значение 1.0, которое фактически отключает фильтр в фазах агрессивного роста).

### Резюме:

Внедрение **Ограничения для Risk Parity (п.1)** вернет вас на кривую эффективного фронта.
Внедрение **Ротационного стопа (п.2)** и **фикс левериджа (п.3)** позволит вам обгонять S&P 500 по доходности в периоды роста.
А **Защитный Risk-Off (п.4)** обеспечит положительную доходность в годы, когда индекс падает.